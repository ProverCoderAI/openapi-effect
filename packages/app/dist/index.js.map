{"version":3,"file":"index.js","sources":["../src/core/api-client/strict-types.ts","../src/core/axioms.ts","../src/shell/api-client/strict-client.ts","../src/shell/api-client/create-client.ts","../src/generated/decoders.ts","../src/generated/dispatch.ts","../src/generated/dispatchers-by-path.ts"],"sourcesContent":["// CHANGE: Define core type-level operations for extracting OpenAPI types\n// WHY: Enable compile-time type safety without runtime overhead through pure type transformations\n// QUOTE(ТЗ): \"Success / HttpError являются коррелированными суммами (status → точный тип body) строго из OpenAPI типов\"\n// REF: issue-2, section 3.1, 4.1-4.3\n// SOURCE: n/a\n// FORMAT THEOREM: ∀ Op ∈ Operations: ResponseVariant<Op> = Success<Op> ⊎ Failure<Op>\n// PURITY: CORE\n// INVARIANT: All types computed at compile time, no runtime operations\n// COMPLEXITY: O(1) compile-time / O(0) runtime\n\nimport type { HttpMethod, PathsWithMethod } from \"openapi-typescript-helpers\"\n\n/**\n * Extract all paths that support a given HTTP method\n *\n * @pure true - compile-time only\n * @invariant Result ⊆ paths\n */\nexport type PathsForMethod<\n  Paths extends object,\n  Method extends HttpMethod\n> = PathsWithMethod<Paths, Method>\n\n/**\n * Extract operation definition for a path and method\n *\n * @pure true - compile-time only\n * @invariant ∀ path ∈ Paths, method ∈ Methods: Operation<Paths, path, method> = Paths[path][method]\n */\nexport type OperationFor<\n  Paths extends object,\n  Path extends keyof Paths,\n  Method extends HttpMethod\n> = Method extends keyof Paths[Path] ? Paths[Path][Method] : never\n\n/**\n * Extract all response definitions from an operation\n *\n * @pure true - compile-time only\n */\nexport type ResponsesFor<Op> = Op extends { responses: infer R } ? R : never\n\n// ============================================================================\n// Request-side typing (path/method → params/query/body)\n// ============================================================================\n\n/**\n * Extract path parameters from operation\n *\n * @pure true - compile-time only\n * @invariant Returns path params type or undefined if none\n */\nexport type PathParamsFor<Op> = Op extends { parameters: { path: infer P } }\n  ? P extends Record<string, infer V> ? Record<string, V>\n  : never\n  : undefined\n\n/**\n * Extract query parameters from operation\n *\n * @pure true - compile-time only\n * @invariant Returns query params type or undefined if none\n */\nexport type QueryParamsFor<Op> = Op extends { parameters: { query?: infer Q } } ? Q\n  : undefined\n\n/**\n * Extract request body type from operation\n *\n * @pure true - compile-time only\n * @invariant Returns body type or undefined if no requestBody\n */\nexport type RequestBodyFor<Op> = Op extends { requestBody: { content: infer C } }\n  ? C extends { \"application/json\": infer J } ? J\n  : C extends { [key: string]: infer V } ? V\n  : never\n  : undefined\n\n/**\n * Check if path params are required\n *\n * @pure true - compile-time only\n */\n\nexport type HasRequiredPathParams<Op> = Op extends { parameters: { path: infer P } }\n  ? P extends Record<PropertyKey, string | number | boolean> ? keyof P extends never ? false : true\n  : false\n  : false\n\n/**\n * Check if request body is required\n *\n * @pure true - compile-time only\n */\nexport type HasRequiredBody<Op> = Op extends { requestBody: infer RB } ? RB extends { content: object } ? true\n  : false\n  : false\n\n/**\n * Build request options type from operation with all constraints\n * - params: required if path has required parameters\n * - query: optional, typed from operation\n * - body: required if operation has requestBody (accepts typed object OR string)\n *\n * For request body:\n * - Users can pass either the typed object (preferred, for type safety)\n * - Or a pre-stringified JSON string with headers (for backwards compatibility)\n *\n * @pure true - compile-time only\n * @invariant Options type is fully derived from operation definition\n */\nexport type RequestOptionsFor<Op> =\n  & (HasRequiredPathParams<Op> extends true ? { readonly params: PathParamsFor<Op> }\n    : { readonly params?: PathParamsFor<Op> })\n  & (HasRequiredBody<Op> extends true ? { readonly body: RequestBodyFor<Op> | BodyInit }\n    : { readonly body?: RequestBodyFor<Op> | BodyInit })\n  & { readonly query?: QueryParamsFor<Op> }\n  & { readonly headers?: HeadersInit }\n  & { readonly signal?: AbortSignal }\n\n/**\n * Extract status codes from responses\n *\n * @pure true - compile-time only\n * @invariant Result = { s | s ∈ keys(Responses) }\n */\nexport type StatusCodes<Responses> = keyof Responses & (number | string)\n\n/**\n * Extract content types for a specific status code\n *\n * @pure true - compile-time only\n */\nexport type ContentTypesFor<\n  Responses,\n  Status extends StatusCodes<Responses>\n> = Status extends keyof Responses ? Responses[Status] extends { content: infer C } ? keyof C & string\n  : \"none\"\n  : never\n\n/**\n * Extract body type for a specific status and content-type\n *\n * @pure true - compile-time only\n * @invariant Strict correlation: Body type depends on both status and content-type\n */\nexport type BodyFor<\n  Responses,\n  Status extends StatusCodes<Responses>,\n  ContentType extends ContentTypesFor<Responses, Status>\n> = Status extends keyof Responses\n  ? Responses[Status] extends { content: infer C } ? ContentType extends keyof C ? C[ContentType]\n    : never\n  : ContentType extends \"none\" ? undefined\n  : never\n  : never\n\n/**\n * Build a correlated success response variant (status + contentType + body)\n * Used for 2xx responses that go to the success channel.\n *\n * @pure true - compile-time only\n * @invariant ∀ variant: variant.body = BodyFor<Responses, variant.status, variant.contentType>\n */\nexport type ResponseVariant<\n  Responses,\n  Status extends StatusCodes<Responses>,\n  ContentType extends ContentTypesFor<Responses, Status>\n> = {\n  readonly status: Status\n  readonly contentType: ContentType\n  readonly body: BodyFor<Responses, Status, ContentType>\n}\n\n/**\n * Build a correlated HTTP error response variant (status + contentType + body + _tag)\n * Used for non-2xx responses (4xx, 5xx) that go to the error channel.\n *\n * The `_tag: \"HttpError\"` discriminator allows distinguishing HTTP errors from BoundaryErrors.\n *\n * @pure true - compile-time only\n * @invariant ∀ variant: variant.body = BodyFor<Responses, variant.status, variant.contentType>\n */\nexport type HttpErrorResponseVariant<\n  Responses,\n  Status extends StatusCodes<Responses>,\n  ContentType extends ContentTypesFor<Responses, Status>\n> = {\n  readonly _tag: \"HttpError\"\n  readonly status: Status\n  readonly contentType: ContentType\n  readonly body: BodyFor<Responses, Status, ContentType>\n}\n\n/**\n * Build all response variants for given responses\n *\n * @pure true - compile-time only\n */\ntype AllResponseVariants<Responses> = StatusCodes<Responses> extends infer Status\n  ? Status extends StatusCodes<Responses>\n    ? ContentTypesFor<Responses, Status> extends infer CT\n      ? CT extends ContentTypesFor<Responses, Status> ? ResponseVariant<Responses, Status, CT>\n      : never\n    : never\n  : never\n  : never\n\n/**\n * Generic 2xx status detection without hardcoding\n * Uses template literal type to check if status string starts with \"2\"\n *\n * Works with any 2xx status including non-standard ones like 250.\n *\n * @pure true - compile-time only\n * @invariant Is2xx<S> = true ⟺ 200 ≤ S < 300\n */\nexport type Is2xx<S extends string | number> = `${S}` extends `2${string}` ? true : false\n\n/**\n * Filter response variants to success statuses (2xx)\n * Uses generic Is2xx instead of hardcoded status list.\n *\n * @pure true - compile-time only\n * @invariant ∀ v ∈ SuccessVariants: Is2xx<v.status> = true\n */\nexport type SuccessVariants<Responses> = AllResponseVariants<Responses> extends infer V\n  ? V extends ResponseVariant<Responses, infer S, infer CT> ? Is2xx<S> extends true ? ResponseVariant<Responses, S, CT>\n    : never\n  : never\n  : never\n\n/**\n * Filter response variants to error statuses (non-2xx from schema)\n * Returns HttpErrorResponseVariant with `_tag: \"HttpError\"` for discrimination.\n * Uses generic Is2xx instead of hardcoded status list.\n *\n * @pure true - compile-time only\n * @invariant ∀ v ∈ HttpErrorVariants: Is2xx<v.status> = false ∧ v.status ∈ Schema ∧ v._tag = \"HttpError\"\n */\nexport type HttpErrorVariants<Responses> = AllResponseVariants<Responses> extends infer V\n  ? V extends ResponseVariant<Responses, infer S, infer CT> ? Is2xx<S> extends true ? never\n    : HttpErrorResponseVariant<Responses, S, CT>\n  : never\n  : never\n\n/**\n * Boundary errors - always present regardless of schema\n *\n * @pure true - compile-time only\n * @invariant These errors represent protocol/parsing failures, not business logic\n */\nexport type TransportError = {\n  readonly _tag: \"TransportError\"\n  readonly error: Error\n}\n\nexport type UnexpectedStatus = {\n  readonly _tag: \"UnexpectedStatus\"\n  readonly status: number\n  readonly body: string\n}\n\nexport type UnexpectedContentType = {\n  readonly _tag: \"UnexpectedContentType\"\n  readonly status: number\n  readonly expected: ReadonlyArray<string>\n  readonly actual: string | undefined\n  readonly body: string\n}\n\nexport type ParseError = {\n  readonly _tag: \"ParseError\"\n  readonly status: number\n  readonly contentType: string\n  readonly error: Error\n  readonly body: string\n}\n\nexport type DecodeError = {\n  readonly _tag: \"DecodeError\"\n  readonly status: number\n  readonly contentType: string\n  readonly error: Error\n  readonly body: string\n}\n\nexport type BoundaryError =\n  | TransportError\n  | UnexpectedStatus\n  | UnexpectedContentType\n  | ParseError\n  | DecodeError\n\n/**\n * Success type for an operation (2xx statuses only)\n *\n * Goes to the **success channel** of Effect.\n * Developers receive this directly without needing to handle errors.\n *\n * @pure true - compile-time only\n * @invariant ∀ v ∈ ApiSuccess: v.status ∈ [200..299]\n */\nexport type ApiSuccess<Responses> = SuccessVariants<Responses>\n\n/**\n * HTTP error responses from schema (non-2xx statuses like 400, 404, 500)\n *\n * Goes to the **error channel** of Effect, forcing explicit handling.\n * These are business-level errors defined in the OpenAPI schema.\n *\n * @pure true - compile-time only\n * @invariant ∀ v ∈ HttpError: v.status ∉ [200..299] ∧ v.status ∈ Schema\n */\nexport type HttpError<Responses> = HttpErrorVariants<Responses>\n\n/**\n * Complete failure type for API operations\n *\n * Includes both schema-defined HTTP errors (4xx, 5xx) and boundary errors.\n * All failures go to the **error channel** of Effect, forcing explicit handling.\n *\n * @pure true - compile-time only\n * @invariant ApiFailure = HttpError ⊎ BoundaryError\n *\n * BREAKING CHANGE: Previously, HTTP errors (404, 500) were in success channel.\n * Now they are in error channel, requiring explicit handling with Effect.catchTag\n * or Effect.match pattern.\n */\nexport type ApiFailure<Responses> = HttpError<Responses> | BoundaryError\n\n/**\n * @deprecated Use ApiSuccess<Responses> for success channel\n * and ApiFailure<Responses> for error channel instead.\n *\n * ApiResponse mixed success and error statuses in one type.\n * New API separates them into proper Effect channels.\n */\nexport type ApiResponse<Responses> = SuccessVariants<Responses> | HttpErrorVariants<Responses>\n\n/**\n * Helper to ensure exhaustive pattern matching\n *\n * @pure true\n * @throws Compile-time error if called with non-never type\n */\nexport const assertNever = (x: never): never => {\n  throw new Error(`Unexpected value: ${JSON.stringify(x)}`)\n}\n","// CHANGE: Create axioms module for type-safe cast operations\n// WHY: Centralize all type assertions in a single auditable location per CLAUDE.md\n// QUOTE(ТЗ): \"as: запрещён в обычном коде; допускается ТОЛЬКО в одном аксиоматическом модуле\"\n// REF: issue-2, section 3.1\n// SOURCE: n/a\n// FORMAT THEOREM: ∀ cast ∈ Axioms: cast(x) → typed(x) ∨ runtime_validated(x)\n// PURITY: CORE\n// EFFECT: none - pure type-level operations\n// INVARIANT: All casts auditable in single file\n// COMPLEXITY: O(1)\n\n/**\n * JSON value type - result of JSON.parse()\n * This is the fundamental type for all parsed JSON values\n */\n/**\n * Cast function for dispatcher factory\n * AXIOM: Dispatcher factory receives valid classify function\n *\n * This enables generated dispatchers to work with heterogeneous Effect unions.\n * The cast is safe because:\n * 1. The classify function is generated from OpenAPI schema\n * 2. All status/content-type combinations are exhaustively covered\n * 3. The returned Effect conforms to Dispatcher signature\n *\n * @pure true\n */\nimport type { Effect } from \"effect\"\nimport type { ApiFailure, ApiSuccess, TransportError } from \"./api-client/strict-types.js\"\n\nexport type Json =\n  | null\n  | boolean\n  | number\n  | string\n  | ReadonlyArray<Json>\n  | { readonly [k: string]: Json }\n\n/**\n * Cast parsed JSON value to typed Json\n * AXIOM: JSON.parse returns a valid Json value\n *\n * @precondition value is result of JSON.parse on valid JSON string\n * @postcondition result conforms to Json type\n * @pure true\n */\nexport const asJson = (value: unknown): Json => value as Json\n\n/**\n * Cast a value to a specific type with const assertion\n * Used for creating literal typed objects in generated code\n *\n * @pure true\n */\nexport const asConst = <T>(value: T): T => value\n\n/**\n * Create a typed RawResponse from raw values\n * AXIOM: HTTP response structure is known at runtime\n *\n * @pure true\n */\nexport type RawResponse = {\n  readonly status: number\n  readonly headers: Headers\n  readonly text: string\n}\n\nexport const asRawResponse = (value: {\n  status: number\n  headers: Headers\n  text: string\n}): RawResponse => value as RawResponse\n\n/**\n * Dispatcher classifies response and applies decoder\n *\n * NEW DESIGN (Effect-native):\n * - Success channel: `ApiSuccess<Responses>` (2xx responses only)\n * - Error channel: `ApiFailure<Responses>` (non-2xx schema errors + boundary errors)\n *\n * This forces developers to explicitly handle HTTP errors (404, 500, etc.)\n * using Effect.catchTag, Effect.match, or similar patterns.\n *\n * @pure false - applies decoders\n * @effect Effect<ApiSuccess, HttpError | BoundaryError, never>\n * @invariant Must handle all statuses and content-types from schema\n */\nexport type Dispatcher<Responses> = (\n  response: RawResponse\n) => Effect.Effect<\n  ApiSuccess<Responses>,\n  Exclude<ApiFailure<Responses>, TransportError>\n>\n\nexport const asDispatcher = <Responses>(\n  fn: (response: RawResponse) => Effect.Effect<unknown, unknown>\n): Dispatcher<Responses> => fn as Dispatcher<Responses>\n\n/**\n * Cast for StrictRequestInit config object\n * AXIOM: Config object has correct structure when all properties assigned\n *\n * @pure true\n */\nexport const asStrictRequestInit = <T>(config: object): T => config as T\n\n/**\n * Classifier function type for dispatcher creation\n * AXIOM: Classify function returns Effect with heterogeneous union types\n *\n * This type uses `unknown` to allow the classify function to return\n * heterogeneous Effect unions from switch statements. The actual types\n * are enforced by the generated dispatcher code.\n *\n * @pure true\n */\nexport type ClassifyFn = (\n  status: number,\n  contentType: string | undefined,\n  text: string\n) => Effect.Effect<unknown, unknown>\n\n/**\n * Cast internal client implementation to typed StrictApiClient\n * AXIOM: Client implementation correctly implements all method constraints\n *\n * This cast is safe because:\n * 1. StrictApiClient type enforces path/method constraints at call sites\n * 2. The runtime implementation correctly builds requests for any path/method\n * 3. Type checking happens at the call site, not in the implementation\n *\n * @pure true\n */\nexport const asStrictApiClient = <T>(client: object): T => client as T\n\n/**\n * Cast default dispatchers registry to specific schema type\n * AXIOM: Default dispatcher registry was registered for the current Paths type\n *\n * @pure true\n */\nexport const asDispatchersFor = <T>(value: unknown): T => value as T\n","// CHANGE: Implement Effect-based HTTP client with Effect-native error handling\n// WHY: Force explicit handling of HTTP errors (4xx, 5xx) via Effect error channel\n// QUOTE(ТЗ): \"каждый запрос возвращает Effect<Success, Failure, never>; Failure включает все инварианты протокола и схемы\"\n// REF: issue-2, section 2, 4, 5.1\n// SOURCE: n/a\n// FORMAT THEOREM: ∀ req ∈ Requests: execute(req) → Effect<ApiSuccess, ApiFailure, R>\n// PURITY: SHELL\n// EFFECT: Effect<ApiSuccess<Op>, ApiFailure<Op>, HttpClient.HttpClient>\n// INVARIANT: 2xx → success channel, non-2xx → error channel (forced handling)\n// COMPLEXITY: O(1) per request / O(n) for body size\n\nimport * as HttpBody from \"@effect/platform/HttpBody\"\nimport * as HttpClient from \"@effect/platform/HttpClient\"\nimport * as HttpClientRequest from \"@effect/platform/HttpClientRequest\"\nimport { Effect } from \"effect\"\nimport type { HttpMethod } from \"openapi-typescript-helpers\"\n\nimport type {\n  ApiFailure,\n  ApiSuccess,\n  DecodeError,\n  OperationFor,\n  ParseError,\n  ResponsesFor,\n  TransportError,\n  UnexpectedContentType,\n  UnexpectedStatus\n} from \"../../core/api-client/strict-types.js\"\nimport {\n  asDispatcher,\n  asJson,\n  asRawResponse,\n  asStrictRequestInit,\n  type ClassifyFn,\n  type Dispatcher,\n  type Json,\n  type RawResponse\n} from \"../../core/axioms.js\"\n\n// Re-export Dispatcher type for consumers\n\n/**\n * Decoder for response body\n *\n * @pure false - may perform validation\n * @effect Effect<T, DecodeError, never>\n */\nexport type Decoder<T> = (\n  status: number,\n  contentType: string,\n  body: string\n) => Effect.Effect<T, DecodeError>\n\n/**\n * Configuration for a strict API client request\n */\nexport type StrictRequestInit<Responses> = {\n  readonly method: HttpMethod\n  readonly url: string\n  readonly dispatcher: Dispatcher<Responses>\n  readonly headers?: HeadersInit\n  readonly body?: BodyInit\n  readonly signal?: AbortSignal\n}\n\n/**\n * Execute HTTP request with Effect-native error handling\n *\n * @param config - Request configuration with dispatcher\n * @returns Effect with success (2xx) and failures (non-2xx + boundary errors)\n *\n * **Effect Channel Design:**\n * - Success channel: `ApiSuccess<Responses>` - 2xx responses only\n * - Error channel: `ApiFailure<Responses>` - HTTP errors (4xx, 5xx) + boundary errors\n *\n * This forces developers to explicitly handle HTTP errors using:\n * - `Effect.catchTag` for specific error types\n * - `Effect.match` for exhaustive handling\n * - `Effect.catchAll` for generic error handling\n *\n * @pure false - performs HTTP request\n * @effect Effect<ApiSuccess<Responses>, ApiFailure<Responses>, HttpClient.HttpClient>\n * @invariant 2xx → success channel, non-2xx → error channel\n * @precondition config.dispatcher handles all schema statuses\n * @postcondition ∀ response: success(2xx) ∨ httpError(non-2xx) ∨ boundaryError\n * @complexity O(1) + O(|body|) for text extraction\n */\nexport const executeRequest = <Responses>(\n  config: StrictRequestInit<Responses>\n): Effect.Effect<ApiSuccess<Responses>, ApiFailure<Responses>, HttpClient.HttpClient> =>\n  Effect.gen(function*() {\n    // STEP 1: Get HTTP client from context\n    const client = yield* HttpClient.HttpClient\n\n    // STEP 2: Build request based on method\n    const request = buildRequest(config)\n\n    // STEP 3: Execute request with error mapping\n    const rawResponse = yield* Effect.mapError(\n      Effect.gen(function*() {\n        const response = yield* client.execute(request)\n        const text = yield* response.text\n        return asRawResponse({\n          status: response.status,\n          headers: toNativeHeaders(response.headers),\n          text\n        })\n      }),\n      (error): TransportError => ({\n        _tag: \"TransportError\",\n        error: error instanceof Error ? error : new Error(String(error))\n      })\n    )\n\n    // STEP 4: Delegate classification to dispatcher (handles status/content-type/decode)\n    return yield* config.dispatcher(rawResponse)\n  })\n\n/**\n * Build HTTP request from config\n *\n * @pure true\n */\nconst buildRequest = <Responses>(config: StrictRequestInit<Responses>): HttpClientRequest.HttpClientRequest => {\n  const methodMap: Record<string, (url: string) => HttpClientRequest.HttpClientRequest> = {\n    get: HttpClientRequest.get,\n    post: HttpClientRequest.post,\n    put: HttpClientRequest.put,\n    patch: HttpClientRequest.patch,\n    delete: HttpClientRequest.del,\n    head: HttpClientRequest.head,\n    options: HttpClientRequest.options\n  }\n\n  const createRequest = methodMap[config.method] ?? HttpClientRequest.get\n  let request = createRequest(config.url)\n\n  // Add headers if provided\n  if (config.headers !== undefined) {\n    const headers = toRecordHeaders(config.headers)\n    request = HttpClientRequest.setHeaders(request, headers)\n  }\n\n  // Add body if provided\n  if (config.body !== undefined) {\n    const bodyText = typeof config.body === \"string\" ? config.body : JSON.stringify(config.body)\n    request = HttpClientRequest.setBody(request, HttpBody.text(bodyText))\n  }\n\n  return request\n}\n\n/**\n * Convert Headers to Record<string, string>\n *\n * @pure true\n */\nconst toRecordHeaders = (headers: HeadersInit): Record<string, string> => {\n  if (headers instanceof Headers) {\n    const result: Record<string, string> = {}\n    for (const [key, value] of headers.entries()) {\n      result[key] = value\n    }\n    return result\n  }\n  if (Array.isArray(headers)) {\n    const result: Record<string, string> = {}\n    for (const headerPair of headers) {\n      const [headerKey, headerValue] = headerPair\n      result[headerKey] = headerValue\n    }\n    return result\n  }\n  return headers\n}\n\n/**\n * Convert @effect/platform Headers to native Headers\n *\n * @pure true\n */\nconst toNativeHeaders = (platformHeaders: { readonly [key: string]: string }): Headers => {\n  const headers = new Headers()\n  for (const [key, value] of Object.entries(platformHeaders)) {\n    headers.set(key, value)\n  }\n  return headers\n}\n\n/**\n * Helper to create dispatcher from switch-based classifier\n *\n * This function uses a permissive type signature to allow generated code\n * to work with any response variant without requiring exact type matching.\n * The classify function can return any Effect with union types for success/error.\n *\n * NOTE: Uses axioms module for type casts to allow heterogeneous Effect\n * unions from switch statements. The returned Dispatcher is properly typed.\n *\n * @pure true - returns pure function\n * @complexity O(1)\n */\n\nexport const createDispatcher = <Responses>(\n  classify: ClassifyFn\n): Dispatcher<Responses> => {\n  return asDispatcher<Responses>((response: RawResponse) => {\n    const contentType = response.headers.get(\"content-type\") ?? undefined\n    return classify(response.status, contentType, response.text)\n  })\n}\n\n/**\n * Helper to parse JSON with error handling\n *\n * @pure false - performs parsing\n * @effect Effect<Json, ParseError, never>\n */\nexport const parseJSON = (\n  status: number,\n  contentType: string,\n  text: string\n): Effect.Effect<Json, ParseError> =>\n  Effect.try({\n    try: () => asJson(JSON.parse(text)),\n    catch: (error): ParseError => ({\n      _tag: \"ParseError\",\n      status,\n      contentType,\n      error: error instanceof Error ? error : new Error(String(error)),\n      body: text\n    })\n  })\n\n/**\n * Helper to create UnexpectedStatus error\n *\n * @pure true\n */\nexport const unexpectedStatus = (status: number, body: string): UnexpectedStatus => ({\n  _tag: \"UnexpectedStatus\",\n  status,\n  body\n})\n\n/**\n * Helper to create UnexpectedContentType error\n *\n * @pure true\n */\nexport const unexpectedContentType = (\n  status: number,\n  expected: ReadonlyArray<string>,\n  actual: string | undefined,\n  body: string\n): UnexpectedContentType => ({\n  _tag: \"UnexpectedContentType\",\n  status,\n  expected,\n  actual,\n  body\n})\n\n/**\n * Generic client interface for any OpenAPI schema with Effect-native error handling\n *\n * **Effect Channel Design:**\n * - Success channel: `ApiSuccess<Op>` - 2xx responses\n * - Error channel: `ApiFailure<Op>` - HTTP errors (4xx, 5xx) + boundary errors\n *\n * @pure false - performs HTTP requests\n * @effect Effect<ApiSuccess<Op>, ApiFailure<Op>, HttpClient.HttpClient>\n */\nexport type StrictClient<Paths extends object> = {\n  readonly GET: <Path extends keyof Paths>(\n    path: Path,\n    options: RequestOptions<Paths, Path, \"get\">\n  ) => Effect.Effect<\n    ApiSuccess<ResponsesFor<OperationFor<Paths, Path, \"get\">>>,\n    ApiFailure<ResponsesFor<OperationFor<Paths, Path, \"get\">>>,\n    HttpClient.HttpClient\n  >\n\n  readonly POST: <Path extends keyof Paths>(\n    path: Path,\n    options: RequestOptions<Paths, Path, \"post\">\n  ) => Effect.Effect<\n    ApiSuccess<ResponsesFor<OperationFor<Paths, Path, \"post\">>>,\n    ApiFailure<ResponsesFor<OperationFor<Paths, Path, \"post\">>>,\n    HttpClient.HttpClient\n  >\n\n  readonly PUT: <Path extends keyof Paths>(\n    path: Path,\n    options: RequestOptions<Paths, Path, \"put\">\n  ) => Effect.Effect<\n    ApiSuccess<ResponsesFor<OperationFor<Paths, Path, \"put\">>>,\n    ApiFailure<ResponsesFor<OperationFor<Paths, Path, \"put\">>>,\n    HttpClient.HttpClient\n  >\n\n  readonly PATCH: <Path extends keyof Paths>(\n    path: Path,\n    options: RequestOptions<Paths, Path, \"patch\">\n  ) => Effect.Effect<\n    ApiSuccess<ResponsesFor<OperationFor<Paths, Path, \"patch\">>>,\n    ApiFailure<ResponsesFor<OperationFor<Paths, Path, \"patch\">>>,\n    HttpClient.HttpClient\n  >\n\n  readonly DELETE: <Path extends keyof Paths>(\n    path: Path,\n    options: RequestOptions<Paths, Path, \"delete\">\n  ) => Effect.Effect<\n    ApiSuccess<ResponsesFor<OperationFor<Paths, Path, \"delete\">>>,\n    ApiFailure<ResponsesFor<OperationFor<Paths, Path, \"delete\">>>,\n    HttpClient.HttpClient\n  >\n}\n\n/**\n * Request options for a specific operation\n */\nexport type RequestOptions<\n  Paths extends object,\n  Path extends keyof Paths,\n  Method extends HttpMethod\n> = {\n  readonly dispatcher: Dispatcher<ResponsesFor<OperationFor<Paths, Path, Method>>>\n  readonly baseUrl: string\n  readonly params?: Record<string, string | number>\n  readonly query?: Record<string, string | number>\n  readonly headers?: HeadersInit\n  readonly body?: BodyInit\n  readonly signal?: AbortSignal\n}\n\n/**\n * Create a strict client for an OpenAPI schema\n *\n * @pure true - returns pure client object\n * @complexity O(1)\n */\nexport const createStrictClient = <Paths extends object>(): StrictClient<\n  Paths\n> => {\n  const makeRequest = <Path extends keyof Paths, Method extends HttpMethod>(\n    method: Method,\n    path: Path,\n    options: RequestOptions<Paths, Path, Method>\n  ) => {\n    let url = `${options.baseUrl}${String(path)}`\n\n    // Replace path parameters\n    if (options.params !== undefined) {\n      for (const [key, value] of Object.entries(options.params)) {\n        url = url.replace(`{${key}}`, encodeURIComponent(String(value)))\n      }\n    }\n\n    // Add query parameters\n    if (options.query !== undefined) {\n      const params = new URLSearchParams()\n      for (const [key, value] of Object.entries(options.query)) {\n        params.append(key, String(value))\n      }\n      url = `${url}?${params.toString()}`\n    }\n\n    // Build config object, only including optional properties if they are defined\n    // This satisfies exactOptionalPropertyTypes constraint\n    const config = asStrictRequestInit<StrictRequestInit<ResponsesFor<OperationFor<Paths, Path, Method>>>>({\n      method,\n      url,\n      dispatcher: options.dispatcher,\n      ...(options.headers !== undefined && { headers: options.headers }),\n      ...(options.body !== undefined && { body: options.body }),\n      ...(options.signal !== undefined && { signal: options.signal })\n    })\n\n    return executeRequest(config)\n  }\n\n  return {\n    GET: (path, options) => makeRequest(\"get\", path, options),\n    POST: (path, options) => makeRequest(\"post\", path, options),\n    PUT: (path, options) => makeRequest(\"put\", path, options),\n    PATCH: (path, options) => makeRequest(\"patch\", path, options),\n    DELETE: (path, options) => makeRequest(\"delete\", path, options)\n  } satisfies StrictClient<Paths>\n}\n\n// CHANGE: Add universal dispatcher that handles any OpenAPI responses generically\n// WHY: Enable createClient<Paths>(options) without code generation or manual dispatcher wiring\n// QUOTE(ТЗ): \"Я не хочу создавать какие-то дополнительные модули\"\n// REF: issue-5\n// SOURCE: n/a\n// FORMAT THEOREM: ∀ status, ct: universalDispatcher(status, ct, text) → success(2xx) ∨ httpError(non-2xx) ∨ boundaryError\n// PURITY: SHELL\n// EFFECT: Effect<ApiSuccess<Responses>, Exclude<ApiFailure<Responses>, TransportError>, never>\n// INVARIANT: 2xx → success channel, non-2xx → error channel, no-content → body: undefined\n// COMPLEXITY: O(1) per dispatch + O(|text|) for JSON parsing\n\n/**\n * Create a universal dispatcher that handles any OpenAPI response generically\n *\n * The universal dispatcher classifies responses by status code range:\n * - 2xx → success channel (ApiSuccess)\n * - non-2xx → error channel (HttpError)\n *\n * For JSON content types, it parses the body. For no-content responses (empty body),\n * it returns undefined body with contentType \"none\".\n *\n * This enables using createClient<Paths>(options) without generating\n * per-operation dispatchers, fulfilling the zero-boilerplate DSL requirement.\n *\n * @pure true - returns pure dispatcher function\n * @complexity O(1) creation + O(|body|) per dispatch\n */\nexport const createUniversalDispatcher = <Responses>(): Dispatcher<Responses> => {\n  return asDispatcher<Responses>((response: RawResponse) => {\n    const contentType = response.headers.get(\"content-type\") ?? undefined\n    const is2xx = response.status >= 200 && response.status < 300\n\n    // No-content response (empty body or 204)\n    if (response.text === \"\" || response.status === 204) {\n      const variant = {\n        status: response.status,\n        contentType: \"none\" as const,\n        body: undefined\n      } as const\n\n      return is2xx\n        ? Effect.succeed(variant)\n        : Effect.fail({\n          _tag: \"HttpError\" as const,\n          ...variant\n        })\n    }\n\n    // JSON content type\n    if (contentType?.includes(\"application/json\")) {\n      return Effect.gen(function*() {\n        const parsed = yield* parseJSON(response.status, \"application/json\", response.text)\n        const variant = {\n          status: response.status,\n          contentType: \"application/json\" as const,\n          body: parsed\n        } as const\n\n        if (is2xx) {\n          return variant\n        }\n        return yield* Effect.fail({\n          _tag: \"HttpError\" as const,\n          ...variant\n        })\n      })\n    }\n\n    // Unknown content type\n    return Effect.fail(unexpectedContentType(\n      response.status,\n      [\"application/json\"],\n      contentType,\n      response.text\n    ))\n  })\n}\n\nexport { type Dispatcher, type RawResponse } from \"../../core/axioms.js\"\n","// CHANGE: Type-safe createClient API with full request-side enforcement\n// WHY: Ensure path/method → operation → request types are all linked\n// QUOTE(ТЗ): \"path + method определяют operation, и из неё выводятся request/response types\"\n// REF: PR#3 blocking review sections 3.2, 3.3\n// SOURCE: n/a\n// PURITY: SHELL\n// EFFECT: Creates Effect-based API client\n// INVARIANT: All operations are type-safe from path → operation → request → response\n// COMPLEXITY: O(1) client creation\n\nimport type * as HttpClient from \"@effect/platform/HttpClient\"\nimport { Effect } from \"effect\"\nimport type { HttpMethod } from \"openapi-typescript-helpers\"\n\nimport { asDispatchersFor, asStrictApiClient, asStrictRequestInit, type Dispatcher } from \"../../core/axioms.js\"\nimport type {\n  ClientEffect,\n  ClientOptions,\n  DispatchersFor,\n  DispatchersForMethod,\n  StrictApiClientWithDispatchers\n} from \"./create-client-types.js\"\nimport type { StrictRequestInit } from \"./strict-client.js\"\nimport { createUniversalDispatcher, executeRequest } from \"./strict-client.js\"\n\nexport type {\n  ClientEffect,\n  ClientOptions,\n  DispatchersFor,\n  StrictApiClient,\n  StrictApiClientWithDispatchers\n} from \"./create-client-types.js\"\nexport { createUniversalDispatcher } from \"./strict-client.js\"\n\n/**\n * Primitive value type for path/query parameters\n *\n * @pure true - type alias only\n */\ntype ParamValue = string | number | boolean\n\n/**\n * Query parameter value - can be primitive or array of primitives\n *\n * @pure true - type alias only\n */\ntype QueryValue = ParamValue | ReadonlyArray<ParamValue>\n\n// CHANGE: Add default dispatcher registry for auto-dispatching createClient\n// WHY: Allow createClient(options) without explicitly passing dispatcher map\n// QUOTE(ТЗ): \"const apiClient = createClient<Paths>(clientOptions)\"\n// REF: user-msg-4\n// SOURCE: n/a\n// FORMAT THEOREM: ∀ call: defaultDispatchers = dispatchersByPath ⇒ createClient uses dispatcher(path, method)\n// PURITY: SHELL\n// EFFECT: none\n// INVARIANT: defaultDispatchers is set before createClient use\n// COMPLEXITY: O(1)\nlet defaultDispatchers: DispatchersFor<object> | undefined\n\n/**\n * Register default dispatcher map used by createClient(options)\n *\n * @pure false - mutates module-level registry\n * @invariant defaultDispatchers set exactly once per app boot\n */\nexport const registerDefaultDispatchers = <Paths extends object>(\n  dispatchers: DispatchersFor<Paths>\n): void => {\n  defaultDispatchers = dispatchers\n}\n\n/**\n * Resolve default dispatcher map or fail fast\n *\n * @pure false - reads module-level registry\n * @invariant defaultDispatchers must be set for auto-dispatching client\n */\nconst resolveDefaultDispatchers = <Paths extends object>(): DispatchersFor<Paths> => {\n  if (defaultDispatchers === undefined) {\n    throw new Error(\"Default dispatchers are not registered. Import generated dispatchers module.\")\n  }\n  return asDispatchersFor<DispatchersFor<Paths>>(defaultDispatchers)\n}\n\nconst applyPathParams = (path: string, params?: Record<string, ParamValue>): string => {\n  if (params === undefined) {\n    return path\n  }\n\n  let url = path\n  for (const [key, value] of Object.entries(params)) {\n    url = url.replace(\"{\" + key + \"}\", encodeURIComponent(String(value)))\n  }\n  return url\n}\n\nconst buildQueryString = (query?: Record<string, QueryValue>): string => {\n  if (query === undefined) {\n    return \"\"\n  }\n\n  const searchParams = new URLSearchParams()\n  for (const [key, value] of Object.entries(query)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        searchParams.append(key, String(item))\n      }\n      continue\n    }\n    searchParams.set(key, String(value))\n  }\n  return searchParams.toString()\n}\n\nconst appendQueryString = (url: string, queryString: string): string => {\n  if (queryString.length === 0) {\n    return url\n  }\n  return url.includes(\"?\") ? url + \"&\" + queryString : url + \"?\" + queryString\n}\n\nconst withBaseUrl = (baseUrl: string | undefined, url: string): string => {\n  // If baseUrl is not provided, keep a relative URL (browser-friendly)\n  if (baseUrl === undefined || baseUrl === \"\") {\n    return url\n  }\n\n  // Construct full URL\n  return new URL(url, baseUrl).toString()\n}\n\n/**\n * Build URL with path parameters and query string\n *\n * @param baseUrl - Base URL for the API\n * @param path - Path template with placeholders\n * @param params - Path parameters to substitute\n * @param query - Query parameters to append\n * @returns Fully constructed URL\n *\n * @pure true\n * @complexity O(n + m) where n = |params|, m = |query|\n */\nconst buildUrl = (\n  baseUrl: string | undefined,\n  path: string,\n  params?: Record<string, ParamValue>,\n  query?: Record<string, QueryValue>\n): string => {\n  const urlWithParams = applyPathParams(path, params)\n  const queryString = buildQueryString(query)\n  const urlWithQuery = appendQueryString(urlWithParams, queryString)\n  return withBaseUrl(baseUrl, urlWithQuery)\n}\n\n/**\n * Check if body is already a BodyInit type (not a plain object needing serialization)\n *\n * @pure true\n */\nconst isBodyInit = (body: BodyInit | object): body is BodyInit =>\n  typeof body === \"string\"\n  || body instanceof Blob\n  || body instanceof ArrayBuffer\n  || body instanceof ReadableStream\n  || body instanceof FormData\n  || body instanceof URLSearchParams\n\n/**\n * Serialize body to BodyInit - passes through BodyInit types, JSON-stringifies objects\n *\n * @pure true\n * @returns BodyInit or undefined, with consistent return path\n */\nconst serializeBody = (body: BodyInit | object | undefined): BodyInit | undefined => {\n  // Early return for undefined\n  if (body === undefined) {\n    return body\n  }\n  // Pass through existing BodyInit types\n  if (isBodyInit(body)) {\n    return body\n  }\n  // Plain object - serialize to JSON string (which is a valid BodyInit)\n  const serialized: BodyInit = JSON.stringify(body)\n  return serialized\n}\n\n/**\n * Check if body requires JSON Content-Type header\n *\n * @pure true\n */\nconst needsJsonContentType = (body: BodyInit | object | undefined): boolean =>\n  body !== undefined\n  && typeof body !== \"string\"\n  && !(body instanceof Blob)\n  && !(body instanceof FormData)\n\nconst toHeadersFromRecord = (\n  headersInit: Record<\n    string,\n    | string\n    | number\n    | boolean\n    | ReadonlyArray<string | number | boolean>\n    | null\n    | undefined\n  >\n): Headers => {\n  const headers = new Headers()\n\n  for (const [key, value] of Object.entries(headersInit)) {\n    if (value === null || value === undefined) {\n      continue\n    }\n    if (Array.isArray(value)) {\n      headers.set(key, value.map(String).join(\",\"))\n      continue\n    }\n    headers.set(key, String(value))\n  }\n\n  return headers\n}\n\n/**\n * Merge headers from client options and request options\n *\n * @pure true\n * @complexity O(n) where n = number of headers\n */\nconst toHeaders = (headersInit: ClientOptions[\"headers\"] | undefined): Headers => {\n  if (headersInit === undefined) {\n    return new Headers()\n  }\n\n  if (headersInit instanceof Headers) {\n    return new Headers(headersInit)\n  }\n\n  if (Array.isArray(headersInit)) {\n    return new Headers(headersInit)\n  }\n\n  return toHeadersFromRecord(headersInit)\n}\n\nconst mergeHeaders = (\n  clientHeaders: ClientOptions[\"headers\"] | undefined,\n  requestHeaders: ClientOptions[\"headers\"] | undefined\n): Headers => {\n  const headers = toHeaders(clientHeaders)\n  const optHeaders = toHeaders(requestHeaders)\n  for (const [key, value] of optHeaders.entries()) {\n    headers.set(key, value)\n  }\n  return headers\n}\n\n/**\n * Request options type for method handlers\n *\n * @pure true - type alias only\n */\ntype MethodHandlerOptions = {\n  params?: Record<string, ParamValue> | undefined\n  query?: Record<string, QueryValue> | undefined\n  body?: BodyInit | object | undefined\n  headers?: ClientOptions[\"headers\"] | undefined\n  signal?: AbortSignal | undefined\n}\n\n/**\n * Create HTTP method handler with full type constraints\n *\n * @param method - HTTP method\n * @param clientOptions - Client configuration\n * @returns Method handler function\n *\n * @pure false - creates function that performs HTTP requests\n * @complexity O(1) handler creation\n */\nconst createMethodHandler = (\n  method: HttpMethod,\n  clientOptions: ClientOptions\n) =>\n<Responses>(\n  path: string,\n  dispatcher: Dispatcher<Responses>,\n  options?: MethodHandlerOptions\n) => {\n  const url = buildUrl(clientOptions.baseUrl, path, options?.params, options?.query)\n  const headers = mergeHeaders(clientOptions.headers, options?.headers)\n  const body = serializeBody(options?.body)\n\n  if (needsJsonContentType(options?.body)) {\n    headers.set(\"Content-Type\", \"application/json\")\n  }\n\n  const config: StrictRequestInit<Responses> = asStrictRequestInit({\n    method,\n    url,\n    dispatcher,\n    headers,\n    body,\n    signal: options?.signal\n  })\n\n  return executeRequest(config)\n}\n\n/**\n * Create method handler that infers dispatcher from map\n *\n * @pure false - creates function that performs HTTP requests\n * @complexity O(1) handler creation\n */\nconst createMethodHandlerWithDispatchers = <Paths extends object, Method extends HttpMethod>(\n  method: Method,\n  clientOptions: ClientOptions,\n  dispatchers: DispatchersForMethod<Paths, Method>\n) =>\n<Path extends keyof DispatchersForMethod<Paths, Method> & string>(\n  path: Path,\n  options?: MethodHandlerOptions\n) =>\n  createMethodHandler(method, clientOptions)(\n    path,\n    dispatchers[path][method],\n    options\n  )\n\n// CHANGE: Create method handler that infers dispatcher from map\n// WHY: Allow per-call API without passing dispatcher parameter\n// QUOTE(ТЗ): \"Зачем передавать что либо в GET\"\n// REF: user-msg-1\n// SOURCE: n/a\n// FORMAT THEOREM: ∀ path ∈ PathsForMethod<Paths, method>: dispatchers[path][method] = Dispatcher<ResponsesFor<Op>>\n// PURITY: SHELL\n// EFFECT: Effect<ApiSuccess<Responses>, ApiFailure<Responses>, HttpClient>\n// INVARIANT: Dispatcher lookup is total for all operations in Paths\n// COMPLEXITY: O(1) runtime + O(1) dispatcher lookup\n/**\n * Create type-safe Effect-based API client\n *\n * The client enforces:\n * 1. Method availability: GET only on paths with `get`, POST only on paths with `post`\n * 2. Dispatcher correlation: must match operation's responses\n * 3. Request options: params/query/body typed from operation\n *\n * @typeParam Paths - OpenAPI paths type from openapi-typescript\n * @param options - Client configuration\n * @returns API client with typed methods for all operations\n *\n * @pure false - creates client that performs HTTP requests\n * @effect Client methods return Effect<Success, Failure, HttpClient>\n * @invariant ∀ path, method: path ∈ PathsForMethod<Paths, method>\n * @complexity O(1) client creation\n *\n * @example\n * ```typescript\n * import createClient from \"openapi-effect\"\n * import type { Paths } from \"./generated/schema\"\n * import \"./generated/dispatchers-by-path\" // registers default dispatchers\n *\n * const client = createClient<Paths>({\n *   baseUrl: \"https://api.example.com\",\n *   credentials: \"include\"\n * })\n *\n * // Type-safe call - dispatcher inferred from path+method\n * const result = yield* client.GET(\"/pets/{petId}\", {\n *   params: { petId: \"123\" }  // Required because getPet has path params\n * })\n *\n * // Compile error: \"/pets/{petId}\" has no \"put\" method\n * // client.PUT(\"/pets/{petId}\", ...) // Type error!\n * ```\n */\nexport const createClient = <Paths extends object>(\n  options: ClientOptions,\n  dispatchers?: DispatchersFor<Paths>\n): StrictApiClientWithDispatchers<Paths> => {\n  const resolvedDispatchers = dispatchers ?? resolveDefaultDispatchers<Paths>()\n\n  return asStrictApiClient<StrictApiClientWithDispatchers<Paths>>({\n    GET: createMethodHandlerWithDispatchers(\"get\", options, resolvedDispatchers),\n    POST: createMethodHandlerWithDispatchers(\"post\", options, resolvedDispatchers),\n    PUT: createMethodHandlerWithDispatchers(\"put\", options, resolvedDispatchers),\n    DELETE: createMethodHandlerWithDispatchers(\"delete\", options, resolvedDispatchers),\n    PATCH: createMethodHandlerWithDispatchers(\"patch\", options, resolvedDispatchers),\n    HEAD: createMethodHandlerWithDispatchers(\"head\", options, resolvedDispatchers),\n    OPTIONS: createMethodHandlerWithDispatchers(\"options\", options, resolvedDispatchers)\n  })\n}\n\n// CHANGE: Add createMethodHandlerWithUniversalDispatcher for zero-boilerplate client\n// WHY: Enable createClientEffect<Paths>(options) without code generation or dispatcher registry\n// QUOTE(ТЗ): \"Я не хочу создавать какие-то дополнительные модули\"\n// REF: issue-5\n// SOURCE: n/a\n// FORMAT THEOREM: ∀ path, method: universalDispatcher handles response classification generically\n// PURITY: SHELL\n// EFFECT: Effect<ApiSuccess<Responses>, ApiFailure<Responses>, HttpClient>\n// INVARIANT: 2xx → success channel, non-2xx → error channel\n// COMPLEXITY: O(1) handler creation + O(1) universal dispatcher creation per call\nconst createMethodHandlerWithUniversalDispatcher = (\n  method: HttpMethod,\n  clientOptions: ClientOptions\n) =>\n(\n  path: string,\n  options?: MethodHandlerOptions\n) =>\n  createMethodHandler(method, clientOptions)(\n    path,\n    createUniversalDispatcher(),\n    options\n  )\n\ntype HttpErrorTag = { readonly _tag: \"HttpError\" }\n\nconst isHttpErrorValue = (error: unknown): error is HttpErrorTag =>\n  typeof error === \"object\"\n  && error !== null\n  && \"_tag\" in error\n  && Reflect.get(error, \"_tag\") === \"HttpError\"\n\nconst exposeHttpErrorsAsValues = <A, E>(\n  request: Effect.Effect<A, E, HttpClient.HttpClient>\n): Effect.Effect<\n  A | Extract<E, HttpErrorTag>,\n  Exclude<E, Extract<E, HttpErrorTag>>,\n  HttpClient.HttpClient\n> =>\n  request.pipe(\n    Effect.catchIf(\n      (error): error is Extract<E, HttpErrorTag> => isHttpErrorValue(error),\n      (error) => Effect.succeed(error)\n    )\n  )\n\nconst createMethodHandlerWithUniversalDispatcherValue = (\n  method: HttpMethod,\n  clientOptions: ClientOptions\n) =>\n(\n  path: string,\n  options?: MethodHandlerOptions\n) =>\n  exposeHttpErrorsAsValues(\n    createMethodHandlerWithUniversalDispatcher(method, clientOptions)(path, options)\n  )\n\n// CHANGE: Add createClientEffect — zero-boilerplate Effect-based API client\n// WHY: Enable the user's desired DSL without any generated code or dispatcher setup\n// QUOTE(ТЗ): \"const apiClientEffect = createClientEffect<Paths>(clientOptions); apiClientEffect.POST('/api/auth/login', { body: credentials })\"\n// REF: issue-5\n// SOURCE: n/a\n// FORMAT THEOREM: ∀ Paths, options: createClientEffect<Paths>(options) → ClientEffect<Paths>\n// PURITY: SHELL\n// EFFECT: Client methods return Effect<ApiSuccess | HttpError, BoundaryError, HttpClient>\n// INVARIANT: ∀ path, method: path ∈ PathsForMethod<Paths, method> (compile-time) ∧ response classified by status range (runtime)\n// COMPLEXITY: O(1) client creation\n/**\n * Create type-safe Effect-based API client with zero boilerplate\n *\n * Uses a universal dispatcher and exposes HTTP statuses as values:\n * - 2xx → success value (ApiSuccess)\n * - non-2xx schema statuses → success value (HttpError with _tag)\n * - boundary/protocol failures stay in error channel\n * - JSON parsed automatically for application/json content types\n *\n * **No code generation needed.** No dispatcher registry needed.\n * Just pass your OpenAPI Paths type and client options.\n *\n * @typeParam Paths - OpenAPI paths type from openapi-typescript\n * @param options - Client configuration (baseUrl, credentials, headers, etc.)\n * @returns API client with typed methods for all operations\n *\n * @pure false - creates client that performs HTTP requests\n * @effect Client methods return Effect<Success, Failure, HttpClient>\n * @invariant ∀ path, method: path ∈ PathsForMethod<Paths, method>\n * @complexity O(1) client creation\n *\n * @example\n * ```typescript\n * import { createClientEffect, type ClientOptions } from \"openapi-effect\"\n * import type { paths } from \"./openapi.d.ts\"\n *\n * const clientOptions: ClientOptions = {\n *   baseUrl: \"https://petstore.example.com\",\n *   credentials: \"include\"\n * }\n * const apiClientEffect = createClientEffect<paths>(clientOptions)\n *\n * // Type-safe call — path, method, and body all enforced at compile time\n * const result = yield* apiClientEffect.POST(\"/api/auth/login\", {\n *   body: { email: \"user@example.com\", password: \"secret\" }\n * })\n * ```\n */\nexport const createClientEffect = <Paths extends object>(\n  options: ClientOptions\n): ClientEffect<Paths> => {\n  return asStrictApiClient<ClientEffect<Paths>>({\n    GET: createMethodHandlerWithUniversalDispatcherValue(\"get\", options),\n    POST: createMethodHandlerWithUniversalDispatcherValue(\"post\", options),\n    PUT: createMethodHandlerWithUniversalDispatcherValue(\"put\", options),\n    DELETE: createMethodHandlerWithUniversalDispatcherValue(\"delete\", options),\n    PATCH: createMethodHandlerWithUniversalDispatcherValue(\"patch\", options),\n    HEAD: createMethodHandlerWithUniversalDispatcherValue(\"head\", options),\n    OPTIONS: createMethodHandlerWithUniversalDispatcherValue(\"options\", options)\n  })\n}\n","// CHANGE: Auto-generated decoder stubs for all operations\n// WHY: Provide type-safe runtime validation entry points\n// QUOTE(ТЗ): \"при изменении схемы сборка обязана падать, пока декодеры не обновлены\"\n// REF: issue-2, section 5.2\n// SOURCE: Generated from tests/fixtures/petstore.openapi.json\n// FORMAT THEOREM: ∀ op, status: decoder(op, status) → Effect<T, DecodeError, never>\n// PURITY: SHELL\n// EFFECT: Effect<T, DecodeError, never>\n// INVARIANT: All decoders return typed DecodeError on failure\n// COMPLEXITY: O(n) where n = size of parsed object\n\nimport { Effect } from \"effect\"\nimport type { DecodeError } from \"../core/api-client/strict-types.js\"\n\n/**\n * JSON value type - result of JSON.parse()\n */\ntype Json = null | boolean | number | string | ReadonlyArray<Json> | { readonly [k: string]: Json }\n\n/**\n * Decoder for listPets status 200 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodelistPets_200 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n\n/**\n * Decoder for listPets status 500 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodelistPets_500 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n\n/**\n * Decoder for createPet status 201 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodecreatePet_201 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n\n/**\n * Decoder for createPet status 400 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodecreatePet_400 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n\n/**\n * Decoder for createPet status 500 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodecreatePet_500 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n\n/**\n * Decoder for getPet status 200 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodegetPet_200 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n\n/**\n * Decoder for getPet status 404 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodegetPet_404 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n\n/**\n * Decoder for getPet status 500 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodegetPet_500 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n\n/**\n * Decoder for deletePet status 404 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodedeletePet_404 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n\n/**\n * Decoder for deletePet status 500 (application/json)\n * STUB: Replace with real schema decoder when needed\n *\n * @pure false - performs validation\n * @effect Effect<T, DecodeError, never>\n */\nexport const decodedeletePet_500 = (\n  _status: number,\n  _contentType: string,\n  _body: string,\n  parsed: Json\n): Effect.Effect<Json, DecodeError> => {\n  // STUB: Always succeeds with parsed value\n  // Replace with: Schema.decodeUnknown(YourSchema)(parsed)\n  return Effect.succeed(parsed)\n\n  // Example of real decoder:\n  // return Effect.mapError(\n  //   Schema.decodeUnknown(YourSchema)(parsed),\n  //   (error): DecodeError => ({\n  //     _tag: \"DecodeError\",\n  //     status,\n  //     contentType,\n  //     error,\n  //     body\n  //   })\n  // )\n}\n","// CHANGE: Auto-generated dispatchers for all operations with Effect-native error handling\n// WHY: Maintain compile-time correlation between status codes and body types\n// QUOTE(ТЗ): \"реализует switch(status) по всем статусам схемы; Failure включает все инварианты протокола и схемы\"\n// REF: issue-2, section 5.2, 4.1-4.3\n// SOURCE: Generated from tests/fixtures/petstore.openapi.json\n// FORMAT THEOREM: ∀ op ∈ Operations: dispatcher(op) → Effect<ApiSuccess, HttpError | BoundaryError>\n// PURITY: SHELL\n// EFFECT: Effect<ApiSuccess<Responses>, HttpError<Responses> | BoundaryError, never>\n// INVARIANT: 2xx → success channel, non-2xx → error channel (forced handling)\n// COMPLEXITY: O(1) per dispatch (Match lookup)\n\nimport { Effect, Match } from \"effect\"\nimport type { Operations } from \"../../tests/fixtures/petstore.openapi.js\"\nimport type { DecodeError, ResponsesFor } from \"../core/api-client/strict-types.js\"\nimport { asConst, type Json } from \"../core/axioms.js\"\nimport {\n  createDispatcher,\n  parseJSON,\n  unexpectedContentType,\n  unexpectedStatus\n} from \"../shell/api-client/strict-client.js\"\nimport * as Decoders from \"./decoders.js\"\n\n// Response types for each operation - used for type inference\ntype ListPetsResponses = ResponsesFor<Operations[\"listPets\"]>\ntype CreatePetResponses = ResponsesFor<Operations[\"createPet\"]>\ntype GetPetResponses = ResponsesFor<Operations[\"getPet\"]>\ntype DeletePetResponses = ResponsesFor<Operations[\"deletePet\"]>\n\n/**\n * Helper: process JSON content type for a given status - returns SUCCESS variant\n * Used for 2xx responses that go to the success channel\n */\nconst processJsonContentSuccess = <S extends number, D>(\n  status: S,\n  contentType: string | undefined,\n  text: string,\n  decoder: (\n    s: number,\n    ct: string,\n    body: string,\n    parsed: Json\n  ) => Effect.Effect<D, DecodeError>\n) =>\n  contentType?.includes(\"application/json\")\n    ? Effect.gen(function*() {\n      const parsed = yield* parseJSON(status, \"application/json\", text)\n      const decoded = yield* decoder(status, \"application/json\", text, parsed)\n      return asConst({\n        status,\n        contentType: \"application/json\" as const,\n        body: decoded\n      })\n    })\n    : Effect.fail(unexpectedContentType(status, [\"application/json\"], contentType, text))\n\n/**\n * Helper: process JSON content type for a given status - returns HTTP ERROR variant\n * Used for non-2xx responses (4xx, 5xx) that go to the error channel.\n *\n * Adds `_tag: \"HttpError\"` discriminator to distinguish from BoundaryError.\n */\nconst processJsonContentError = <S extends number, D>(\n  status: S,\n  contentType: string | undefined,\n  text: string,\n  decoder: (\n    s: number,\n    ct: string,\n    body: string,\n    parsed: Json\n  ) => Effect.Effect<D, DecodeError>\n) =>\n  contentType?.includes(\"application/json\")\n    ? Effect.gen(function*() {\n      const parsed = yield* parseJSON(status, \"application/json\", text)\n      const decoded = yield* decoder(status, \"application/json\", text, parsed)\n      // Non-2xx: Return as FAILURE with _tag discriminator (goes to error channel)\n      return yield* Effect.fail(asConst({\n        _tag: \"HttpError\" as const,\n        status,\n        contentType: \"application/json\" as const,\n        body: decoded\n      }))\n    })\n    : Effect.fail(unexpectedContentType(status, [\"application/json\"], contentType, text))\n\n/**\n * Dispatcher for listPets\n * Handles statuses: 200 (success), 500 (error)\n *\n * Effect channel mapping:\n * - 200: success channel → ApiSuccess\n * - 500: error channel → HttpError (forces explicit handling)\n *\n * @pure false - applies decoders\n * @invariant Exhaustive coverage of all schema statuses\n */\nexport const dispatcherlistPets = createDispatcher<ListPetsResponses>((status, contentType, text) =>\n  Match.value(status).pipe(\n    Match.when(200, () => processJsonContentSuccess(200, contentType, text, Decoders.decodelistPets_200)),\n    Match.when(500, () => processJsonContentError(500, contentType, text, Decoders.decodelistPets_500)),\n    Match.orElse(() => Effect.fail(unexpectedStatus(status, text)))\n  )\n)\n\n/**\n * Dispatcher for createPet\n * Handles statuses: 201 (success), 400 (error), 500 (error)\n *\n * Effect channel mapping:\n * - 201: success channel → ApiSuccess\n * - 400, 500: error channel → HttpError (forces explicit handling)\n *\n * @pure false - applies decoders\n * @invariant Exhaustive coverage of all schema statuses\n */\nexport const dispatchercreatePet = createDispatcher<CreatePetResponses>((status, contentType, text) =>\n  Match.value(status).pipe(\n    Match.when(201, () => processJsonContentSuccess(201, contentType, text, Decoders.decodecreatePet_201)),\n    Match.when(400, () => processJsonContentError(400, contentType, text, Decoders.decodecreatePet_400)),\n    Match.when(500, () => processJsonContentError(500, contentType, text, Decoders.decodecreatePet_500)),\n    Match.orElse(() => Effect.fail(unexpectedStatus(status, text)))\n  )\n)\n\n/**\n * Dispatcher for getPet\n * Handles statuses: 200 (success), 404 (error), 500 (error)\n *\n * Effect channel mapping:\n * - 200: success channel → ApiSuccess\n * - 404, 500: error channel → HttpError (forces explicit handling)\n *\n * @pure false - applies decoders\n * @invariant Exhaustive coverage of all schema statuses\n */\nexport const dispatchergetPet = createDispatcher<GetPetResponses>((status, contentType, text) =>\n  Match.value(status).pipe(\n    Match.when(200, () => processJsonContentSuccess(200, contentType, text, Decoders.decodegetPet_200)),\n    Match.when(404, () => processJsonContentError(404, contentType, text, Decoders.decodegetPet_404)),\n    Match.when(500, () => processJsonContentError(500, contentType, text, Decoders.decodegetPet_500)),\n    Match.orElse(() => Effect.fail(unexpectedStatus(status, text)))\n  )\n)\n\n/**\n * Dispatcher for deletePet\n * Handles statuses: 204 (success), 404 (error), 500 (error)\n *\n * Effect channel mapping:\n * - 204: success channel → ApiSuccess (no content)\n * - 404, 500: error channel → HttpError (forces explicit handling)\n *\n * @pure false - applies decoders\n * @invariant Exhaustive coverage of all schema statuses\n */\nexport const dispatcherdeletePet = createDispatcher<DeletePetResponses>((status, contentType, text) =>\n  Match.value(status).pipe(\n    Match.when(204, () =>\n      Effect.succeed(\n        asConst({\n          status: 204,\n          contentType: \"none\" as const,\n          body: undefined\n        })\n      )),\n    Match.when(404, () => processJsonContentError(404, contentType, text, Decoders.decodedeletePet_404)),\n    Match.when(500, () => processJsonContentError(500, contentType, text, Decoders.decodedeletePet_500)),\n    Match.orElse(() => Effect.fail(unexpectedStatus(status, text)))\n  )\n)\n","// CHANGE: Auto-generated dispatcher map by path+method\n// WHY: Provide a single dispatcher registry without manual wiring in examples\n// QUOTE(ТЗ): \"Этого в плане вообще не должно быть\"\n// REF: user-msg-3\n// SOURCE: Generated from tests/fixtures/petstore.openapi.json\n// FORMAT THEOREM: ∀ path, method: dispatchersByPath[path][method] = dispatcher(op)\n// PURITY: SHELL\n// EFFECT: none\n// INVARIANT: dispatcher map is total for all operations in Paths\n// COMPLEXITY: O(1)\n\nimport type { Paths } from \"../../tests/fixtures/petstore.openapi.js\"\nimport { type DispatchersFor, registerDefaultDispatchers } from \"../shell/api-client/create-client.js\"\nimport { dispatchercreatePet, dispatcherdeletePet, dispatchergetPet, dispatcherlistPets } from \"./dispatch.js\"\n\n/**\n * Dispatcher map keyed by OpenAPI path and HTTP method\n */\nexport const dispatchersByPath: DispatchersFor<Paths> = {\n  \"/pets\": {\n    get: dispatcherlistPets,\n    post: dispatchercreatePet\n  },\n  \"/pets/{petId}\": {\n    get: dispatchergetPet,\n    delete: dispatcherdeletePet\n  }\n}\n\n// CHANGE: Register default dispatchers at module load\n// WHY: Enable createClient(options) without passing dispatcher map\n// QUOTE(ТЗ): \"const apiClient = createClient<Paths>(clientOptions)\"\n// REF: user-msg-4\n// SOURCE: n/a\n// FORMAT THEOREM: ∀ call: createClient(options) uses dispatchersByPath\n// PURITY: SHELL\n// EFFECT: none\n// INVARIANT: registerDefaultDispatchers is called exactly once per module load\n// COMPLEXITY: O(1)\nregisterDefaultDispatchers(dispatchersByPath)\n"],"names":["assertNever","x","asJson","value","asConst","asRawResponse","asDispatcher","fn","asStrictRequestInit","config","asStrictApiClient","client","asDispatchersFor","executeRequest","Effect","HttpClient","request","buildRequest","rawResponse","response","text","toNativeHeaders","error","HttpClientRequest","headers","toRecordHeaders","bodyText","HttpBody","result","key","headerPair","headerKey","headerValue","platformHeaders","createDispatcher","classify","contentType","parseJSON","status","unexpectedStatus","body","unexpectedContentType","expected","actual","createStrictClient","makeRequest","method","path","options","url","params","createUniversalDispatcher","is2xx","variant","parsed","defaultDispatchers","registerDefaultDispatchers","dispatchers","resolveDefaultDispatchers","applyPathParams","buildQueryString","query","searchParams","item","appendQueryString","queryString","withBaseUrl","baseUrl","buildUrl","urlWithParams","urlWithQuery","isBodyInit","serializeBody","needsJsonContentType","toHeadersFromRecord","headersInit","toHeaders","mergeHeaders","clientHeaders","requestHeaders","optHeaders","createMethodHandler","clientOptions","dispatcher","createMethodHandlerWithDispatchers","createClient","resolvedDispatchers","createMethodHandlerWithUniversalDispatcher","isHttpErrorValue","exposeHttpErrorsAsValues","createMethodHandlerWithUniversalDispatcherValue","createClientEffect","decodelistPets_200","_status","_contentType","_body","decodelistPets_500","decodecreatePet_201","decodecreatePet_400","decodecreatePet_500","decodegetPet_200","decodegetPet_404","decodegetPet_500","decodedeletePet_404","decodedeletePet_500","processJsonContentSuccess","decoder","decoded","processJsonContentError","dispatcherlistPets","Match","Decoders.decodelistPets_200","Decoders.decodelistPets_500","dispatchercreatePet","Decoders.decodecreatePet_201","Decoders.decodecreatePet_400","Decoders.decodecreatePet_500","dispatchergetPet","Decoders.decodegetPet_200","Decoders.decodegetPet_404","Decoders.decodegetPet_500","dispatcherdeletePet","Decoders.decodedeletePet_404","Decoders.decodedeletePet_500","dispatchersByPath"],"mappings":"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"}