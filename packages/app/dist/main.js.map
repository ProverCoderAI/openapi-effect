{"version":3,"file":"main.js","sources":["../src/core/greeting.ts","../src/shell/cli.ts","../src/app/program.ts","../src/app/main.ts"],"sourcesContent":["import { Match } from \"effect\"\n\nexport type GreetingVariant =\n  | { readonly kind: \"effect\" }\n  | { readonly kind: \"named\"; readonly name: string }\n\n/**\n * Formats a greeting message without side effects.\n *\n * @param variant - Non-empty, classified name information.\n * @returns Greeting text composed deterministically.\n *\n * @pure true\n * @invariant variant.kind === \"named\" â‡’ variant.name.length > 0\n * @complexity O(1) time / O(1) space\n */\nexport const formatGreeting = (variant: GreetingVariant): string =>\n  Match.value(variant).pipe(\n    Match.when({ kind: \"effect\" }, () => \"Hello from Effect!\"),\n    Match.when({ kind: \"named\" }, ({ name }) => `Hello, ${name}!`),\n    Match.exhaustive\n  )\n","import * as S from \"@effect/schema/Schema\"\nimport { Effect, pipe } from \"effect\"\n\nimport type { GreetingVariant } from \"../core/greeting.js\"\n\nconst cliSchema = S.Struct({\n  name: S.optionalWith(S.NonEmptyString, { default: () => \"Effect\" })\n})\n\ntype CliInput = S.Schema.Type<typeof cliSchema>\n\nconst toVariant = (input: CliInput): GreetingVariant =>\n  input.name.toLowerCase() === \"effect\"\n    ? { kind: \"effect\" }\n    : { kind: \"named\", name: input.name }\n\nexport const readGreetingVariant = pipe(\n  Effect.sync(() => process.argv.slice(2)),\n  Effect.map((args) => args.length > 0 && args[0] !== undefined ? { name: args[0] } : {}),\n  Effect.flatMap(S.decodeUnknown(cliSchema)),\n  Effect.map((input) => toVariant(input))\n)\n","import { Console, Effect, pipe } from \"effect\"\n\nimport { formatGreeting } from \"../core/greeting.js\"\nimport { readGreetingVariant } from \"../shell/cli.js\"\n\n/**\n * Compose the CLI program as a single effect.\n *\n * @returns Effect that returns the greeting string and logs it once on success.\n *\n * @pure false - uses Console output\n * @effect Console\n * @invariant forall args in Argv: decode(args) = v -> logs exactly one greeting\n * @precondition true\n * @postcondition exists greeting: returned(greeting) and logged(greeting)\n * @complexity O(1)\n * @throws Never - all errors are typed in the Effect error channel\n */\n// CHANGE: extract the composed program into a reusable Effect\n// WHY: keep the entrypoint as a thin platform runtime shell and make testing deterministic\n// QUOTE(TZ): \"\\u0414\\u0430 \\u0434\\u0430\\u0432\\u0430\\u0439 \\u0442\\u0430\\u043a \\u044d\\u0442\\u043e \\u0431\\u043e\\u043b\\u0435\\u0435 \\u043f\\u0440\\u0430\\u0432\\u0438\\u043b\\u044c\\u043d\\u0430\\u044f \\u0440\\u0435\\u0430\\u043b\\u0438\\u0437\\u0430\\u0446\\u0438\\u044f\"\n// REF: user-2025-12-19-platform-node\n// SOURCE: https://effect.website/docs/platform/runtime/ \"runMain helps you execute a main effect with built-in error handling, logging, and signal management.\"\n// FORMAT THEOREM: forall args in Argv: decode(args) = v -> log(formatGreeting(v))\n// PURITY: SHELL\n// EFFECT: Effect<string, S.ParseError, Console>\n// INVARIANT: exactly one log entry per successful parse\n// COMPLEXITY: O(1)/O(1)\nexport const program = pipe(\n  readGreetingVariant,\n  Effect.map((variant) => formatGreeting(variant)),\n  Effect.tap(Console.log)\n)\n","import { NodeContext, NodeRuntime } from \"@effect/platform-node\"\nimport { Effect, pipe } from \"effect\"\n\nimport { program } from \"./program.js\"\n\n// CHANGE: run the program through the Node platform runtime with its layer\n// WHY: ensure effects execute under the platform runtime with proper teardown/logging behavior\n// QUOTE(TZ): \"\\u0414\\u0430 \\u0434\\u0430\\u0432\\u0430\\u0439 \\u0442\\u0430\\u043a \\u044d\\u0442\\u043e \\u0431\\u043e\\u043b\\u0435\\u0435 \\u043f\\u0440\\u0430\\u0432\\u0438\\u043b\\u044c\\u043d\\u0430\\u044f \\u0440\\u0435\\u0430\\u043b\\u0438\\u0437\\u0430\\u0446\\u0438\\u044f\"\n// REF: user-2025-12-19-platform-node\n// SOURCE: https://effect.website/docs/platform/runtime/ \"runMain helps you execute a main effect with built-in error handling, logging, and signal management.\"\n// FORMAT THEOREM: forall args in Argv: decode(args) = v -> runMain(program)\n// PURITY: SHELL\n// EFFECT: Effect<string, S.ParseError, Console>\n// INVARIANT: program executed with NodeContext.layer\n// COMPLEXITY: O(1)/O(1)\nconst main = pipe(program, Effect.provide(NodeContext.layer))\n\nNodeRuntime.runMain(main)\n"],"names":["formatGreeting","variant","Match","name","cliSchema","S","toVariant","input","readGreetingVariant","pipe","Effect","args","program","Console","main","NodeContext","NodeRuntime"],"mappings":"+KAgBO,MAAMA,EAAkBC,GAC7BC,EAAM,MAAMD,CAAO,EAAE,KACnBC,EAAM,KAAK,CAAE,KAAM,QAAA,EAAY,IAAM,oBAAoB,EACzDA,EAAM,KAAK,CAAE,KAAM,OAAA,EAAW,CAAC,CAAE,KAAAC,CAAA,IAAW,UAAUA,CAAI,GAAG,EAC7DD,EAAM,UACR,EChBIE,EAAYC,EAAE,OAAO,CACzB,KAAMA,EAAE,aAAaA,EAAE,eAAgB,CAAE,QAAS,IAAM,QAAA,CAAU,CACpE,CAAC,EAIKC,EAAaC,GACjBA,EAAM,KAAK,gBAAkB,SACzB,CAAE,KAAM,UACR,CAAE,KAAM,QAAS,KAAMA,EAAM,IAAA,EAEtBC,EAAsBC,EACjCC,EAAO,KAAK,IAAM,QAAQ,KAAK,MAAM,CAAC,CAAC,EACvCA,EAAO,IAAKC,GAASA,EAAK,OAAS,GAAKA,EAAK,CAAC,IAAM,OAAY,CAAE,KAAMA,EAAK,CAAC,CAAA,EAAM,EAAE,EACtFD,EAAO,QAAQL,EAAE,cAAcD,CAAS,CAAC,EACzCM,EAAO,IAAKH,GAAUD,EAAUC,CAAK,CAAC,CACxC,ECOaK,EAAUH,EACrBD,EACAE,EAAO,IAAKT,GAAYD,EAAeC,CAAO,CAAC,EAC/CS,EAAO,IAAIG,EAAQ,GAAG,CACxB,ECjBMC,EAAOL,EAAKG,EAASF,EAAO,QAAQK,EAAY,KAAK,CAAC,EAE5DC,EAAY,QAAQF,CAAI"}